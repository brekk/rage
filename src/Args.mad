import type { Parser } from "Parse"

import { gt } from "Compare"
import { identity, ifElse, when } from "Function"
import IO from "IO"
import List from "List"
import { Just, Nothing } from "Maybe"
import { anyChar, char, choice, eof, someTill, string } from "Parse"
import String from "String"
import { fromList, trim } from "String"



type Flag = FlagOn(String) | FlagOff(String) | Flag(String, String)
isStringFlag = String.startsWith("--")
isNegated = String.startsWith("--no-")
isShortFlag = String.startsWith("-")
isFlag = (x) => isShortFlag(x) || isStringFlag(x) || isNegated(x)

export type Specific
  = Name(String)
  | Description(String)
  | Ignore(String)
  | Repo(String)
  | UseAliases(Boolean)

splitJointFlags = (x) => String.includes('=', x)
  ? String.split("=", x)
  : isShortFlag(x) && !isStringFlag(x)
    ? pipe(
      String.drop(1),
      String.split(""),
      map(mappend("-")),
    )(x)
    : of(x)

handleMultipleBooleanFlags = (stack, x) => List.concat(
  stack,
  map(
    pipe(
      String.drop(1),
      FlagOn,
    ),
    x,
  ),
)

handleStringFlag = (stack, curr, fixed) => where(List.nth(0, curr)) {
  Just(firstCurr) =>
    !isFlag(firstCurr) ? List.append(Flag(fixed, firstCurr), stack) : stack

  _ =>
    stack
}


handleBooleanFlag = (stack, prev, fixed) => !isFlag(prev)
  ? stack
  : List.append((isNegated(prev) ? FlagOff : FlagOn)(fixed), stack)

cleanFlag = ifElse(isNegated, String.drop(5), ifElse(isStringFlag, String.drop(2), String.drop(1)))

handleOtherFlags = (stack, prev, current) => do {
  fixed = cleanFlag(prev)
  currentIsSingle = List.length(current) == 1
  return if (isStringFlag(prev) || isShortFlag(prev) && currentIsSingle) do {
    return if (isNegated(prev)) {
      List.append(FlagOff(fixed), stack)
    } else if (currentIsSingle) {
      handleStringFlag(stack, current, fixed)
    } else {
      stack
    }
  } else do {
    return where(List.nth(0, current)) {
      Just(firstCurr) =>
        handleBooleanFlag(stack, prev, fixed)

      _ =>
        stack
    }
  }
}

updateStack = (stack, maybePrevious, current) => where(maybePrevious) {
  Just(previous) =>
    do {
      previousIsSingle = List.length(previous) == 1
      previousIsPair = List.length(previous) == 2
      return if (!previousIsSingle && !previousIsPair) {
        handleMultipleBooleanFlags(stack, previous)
      } else if (previousIsPair) {
        where(previous) {
          [k, v] =>
            isFlag(k) && !isFlag(v)
              ? List.append(Flag(cleanFlag(k), v), stack)
              : handleMultipleBooleanFlags(stack, previous)

          _ =>
            stack
        }
      } else {
        where(List.nth(0, previous)) {
          Just(x) =>
            handleOtherFlags(stack, x, current)

          Nothing =>
            stack
        }
      }
    }

  Nothing =>
    stack
}

convertFlags :: List String -> List Flag
export convertFlags = pipe(
  map(splitJointFlags),
  (steps) => List.reduce(
    (agg, curr) => ({ prev: Just(curr), stack: updateStack(agg.stack, agg.prev, curr) }),
    { stack: [], prev: List.nth(0, steps) },
    // stuff an empty value at the end so we process all entries
    List.append([], List.tail(steps)),
  ),
  .stack,
)
