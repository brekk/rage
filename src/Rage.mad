import type { Error } from "File"
import type { Wish } from "Wish"

import type { CommandWish } from "@/External"

import { apL } from "Applicative"
import File from "File"
import { always, identity } from "Function"
import IO from "IO"
import { concat } from "List"
import { bad, good, mapRej } from "Wish"

import Ext from "@/External"
import Git from "@/Git"
import { log } from "@/Log"



export signal = (_bad, _good) => pipe(
  mapRej(
    pipe(
      log.detail("signal, pre-fail"),
      always(_bad),
      log.error("ERROR"),
    ),
  ),
  map(
    pipe(
      always(_good),
      log.status("PROGRESS"),
    ),
  ),
)

export type Project = Library | Tool | Other

/*
description :: String - a description of the project
ignore :: String - a path to pull a .gitignore value from 
kind :: Project - what kind of project is this? 
name :: String - the name of the project 
repo :: String - the owner/repo path 
template :: String - the project repo to pull from 
useImportAliases :: Boolean - do we wanna use import aliases? 
*/
export alias ProjectDef = {
  description :: String,
  ignore :: String,
  kind :: Project,
  name :: String,
  repo :: String,
  template :: String,
  useImportAliases :: Boolean,
}
export alias RageDef = { ...ProjectDef, handleGit :: Boolean, log :: Boolean }

export type ProjectError
  = ScaffoldFail
  | JsonNotCreated
  | ReadmeNotUpdated
  | RepoNotInitialized
  | InvalidRepo
  | InvalidTemplate
  | InvalidIgnore
  | GenericError

export handleProjectError = where {
  ScaffoldFail =>
    "Unable to create project scaffold"

  JsonNotCreated =>
    "Unable to create madlib.json"

  ReadmeNotUpdated =>
    "Unable to alter README.md"

  RepoNotInitialized =>
    "Unable to initialize git repository"

  InvalidRepo =>
    "Given repo is not valid"

  InvalidTemplate =>
    "Given template repo is not valid"

  InvalidIgnore =>
    "Unable to copy the .gitignore file via curl"

  GenericError =>
    "The machine is sick"
}

export type ProjectStatus
  = Scaffold
  | GitIgnored
  | JsonCreated
  | ReadmeUpdated
  | RepoInitialized
  | RepoCreated
  | RemoteSet
  | Ready

export handleProjectStatus = where {
  Scaffold =>
    "Created project folder"

  GitIgnored =>
    "Pulled a .gitignore file via curl"

  JsonCreated =>
    "Created the madlib.json file"

  ReadmeUpdated =>
    "Updated the project README.md"

  RepoInitialized =>
    "Git repo initialized"

  RepoCreated =>
    "Created github repo programmatically"

  RemoteSet =>
    "Pushed project to git remote"

  Ready =>
    "Got mad, quickly"
}

export alias RageState = Wish ProjectError ProjectStatus

_makeProjectDirectory :: RageDef -> CommandWish
export _makeProjectDirectory = where {
  { name } =>
    Ext.mkdir([name])
}

rawJson = (name) => `{
  "name": "${name}",
  "version": "0.0.1",
  "main": "src/Main.mad",
  "importAliases": {
    ".": "src"
  }
}`

_createMadlibJson = where {
  { name } =>
    do {
      dir <- pipe(
        Ext.mkdir,
        signal(ScaffoldFail, Scaffold),
      )([name])
      file <- pipe(
        rawJson,
        File.write(`${name}/madlib.json`),
        signal(JsonNotCreated, JsonCreated),
      )(name)
      return pipe(
        of,
      )(file)
    }
}

createMadlibProject :: RageDef -> RageState
export createMadlibProject = pipe(
  _createMadlibJson,
)

_pullGitignore :: RageDef -> CommandWish
export _pullGitignore = where {
  { name, ignore } =>
    Ext.curl([ignore, "-o", `${name}/.gitignore`])
}

pullGitignore :: RageDef -> RageState
export pullGitignore = pipe(
  _pullGitignore,
  signal(InvalidIgnore, GitIgnored),
)

_overwriteReadme :: RageDef -> Wish Error {}
export _overwriteReadme = where {
  { name, description } =>
    File.write(`${name}/README.md`, `# ${name}\n${description}`)
}

overwriteReadme :: RageDef -> RageState
export overwriteReadme = pipe(
  _overwriteReadme,
  signal(ReadmeNotUpdated, ReadmeUpdated),
)

setGitRemote :: RageDef -> RageState
setGitRemote = pipe(
  .repo,
  Git.setRemote,
  signal(InvalidRepo, RemoteSet),
)

// gitInit :: RageDef -> RageState
// gitInit = pipe(
//   Git.init,
//   signal(RepoNotInitialized, RepoInitialized),
// )


runGitCommands :: RageDef -> RageState -> RageState
runGitCommands = (def, s) => pipe(
  // gitInit,
  apL(pullGitignore(def)),
  // apL(setGitRemote(def)),

)(s)


// create :: RageDef -> RageState
export create = (def) => pipe(
  // create a new madlib project (madlib new <project>)
  createMadlibProject,
  // pull down the .gitignore file (curl path > .gitignore)
  def.handleGit ? runGitCommands(def) : identity,
)(def)
