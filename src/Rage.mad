import type { Error } from "File"
import type { Wish } from "Wish"

import type { CommandWish } from "@/External"

import { apL } from "Applicative"
import File from "File"
import { always, identity } from "Function"
import { concat } from "List"
import { good, mapRej } from "Wish"

import Ext from "@/External"
import { setRemote } from "@/Git"
import { log } from "@/Log"



signal = (_bad, _good) => pipe(
  mapRej(
    pipe(
      always(_bad),
      log.error("ERROR"),
    ),
  ),
  map(
    pipe(
      always(_good),
      log.status("PROGRESS"),
    ),
  ),
)

export type Project = Library | Tool | Other

/*
description :: String - a description of the project
ignore :: String - a path to pull a .gitignore value from 
kind :: Project - what kind of project is this? 
name :: String - the name of the project 
repo :: String - the owner/repo path 
template :: String - the project repo to pull from 
useImportAliases :: Boolean - do we wanna use import aliases? 
*/
export alias ProjectDef = {
  description :: String,
  ignore :: String,
  kind :: Project,
  name :: String,
  repo :: String,
  template :: String,
  useImportAliases :: Boolean,
}
export alias RageDef = { ...ProjectDef, handleGit :: Boolean, log :: Boolean }

export type ProjectError
  = ScaffoldFail
  | JsonNotUpdated
  | ReadmeNotUpdated
  | InvalidRepo
  | InvalidTemplate
  | InvalidIgnore
  | GenericError

export handleProjectError = where {
  ScaffoldFail =>
    "Unable to create project scaffold"

  JsonNotUpdated =>
    "Unable to update madlib.json"

  ReadmeNotUpdated =>
    "Unable to alter README.md"

  InvalidRepo =>
    "Given repo is not valid"

  InvalidTemplate =>
    "Given template repo is not valid"

  InvalidIgnore =>
    "Unable to copy the .gitignore file via curl"

  GenericError =>
    "The machine is sick"
}

export type ProjectStatus
  = Scaffold
  | GitIgnored
  | JsonUpdated
  | ReadmeUpdated
  | RepoCreated
  | RemoteSet
  | Ready

export handleProjectStatus = where {
  Scaffold =>
    "Created project via `madlib new`"

  GitIgnored =>
    "Pulled a .gitignore file via curl"

  JsonUpdated =>
    "Updated the madlib.json file"

  ReadmeUpdated =>
    "Updated the project README.md"

  RepoCreated =>
    "Created github repo programmatically"

  RemoteSet =>
    "Pushed project to git remote"

  Ready =>
    "Got mad, quickly"
}

export alias RageState = Wish ProjectError ProjectStatus

_createMadlibProject :: RageDef -> CommandWish
export _createMadlibProject = pipe(
  .name,
  of,
  concat(["new"]),
  Ext.madlib,
)

createMadlibProject :: RageDef -> RageState
export createMadlibProject = pipe(
  _createMadlibProject,
  signal(ScaffoldFail, Scaffold),
)

_pullGitignore :: RageDef -> CommandWish
export _pullGitignore = where {
  { name, ignore } =>
    Ext.curl([ignore, "-o", `${name}/.gitignore`])
}

pullGitignore :: RageDef -> RageState
export pullGitignore = pipe(
  _pullGitignore,
  signal(InvalidIgnore, GitIgnored),
)

_overwriteMadlibJson :: RageDef -> Wish Error {}
export _overwriteMadlibJson = where {
  { name } =>
    File.write(
      `${name}/madlib.json`,
      `{
  "name": "${name}",
  "version": "0.0.1",
  "main": "src/Main.mad",
  "importAliases": {
    ".": "src"
  }
}`,
    )
}

overwriteMadlibJson :: RageDef -> RageState
export overwriteMadlibJson = pipe(
  _overwriteMadlibJson,
  signal(JsonNotUpdated, JsonUpdated),
)

_overwriteReadme :: RageDef -> Wish Error {}
export _overwriteReadme = where {
  { name, description } =>
    File.write(`${name}/README.md`, `# ${name}\n${description}`)
}

overwriteReadme :: RageDef -> RageState
export overwriteReadme = pipe(
  _overwriteReadme,
  signal(ReadmeNotUpdated, ReadmeUpdated),
)

setGitRemote :: RageDef -> RageState
setGitRemote = pipe(
  .repo,
  setRemote,
  signal(InvalidRepo, RemoteSet),
)

runGitCommands :: RageDef -> RageState -> RageState
runGitCommands = (def, s) => pipe(
  apL(pullGitignore(def)),
  apL(setGitRemote(def)),
)(s)


create :: RageDef -> RageState
export create = (def) => pipe(
  // create a new madlib project (madlib new <project>)
  createMadlibProject,
  // change directory? (cd <project>)
  // update the madlib.json file (raw fs.write)
  apL(overwriteMadlibJson(def)),
  // update the README.md (raw fs.write)
  apL(overwriteReadme(def)),
  // set the remote origin (git remote add origin <repo>)
  // pull down the .gitignore file (curl path > .gitignore)
  def.handleGit ? runGitCommands(def) : identity,
  // push it real good (git push --set-upstream origin main)


)(def)
